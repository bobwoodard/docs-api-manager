= Custom Policy Development Reference
ifndef::env-site,env-github[]
include::_attributes.adoc[]
endif::[]

The Mule 4 engine is more powerful than its predecessor for building custom policies that leverage Mule core concepts and language.
For developing policies, Maven is the most useful tool. Policies consist of two files: A deployable JAR where the
logic implementation resides and a YAML Configuration File, where the policy parameters and metadata are defined.

In order to be able to package a policy, the development project has to be composed of the following files:

* An XML template
+
Contains the implementation of the policy in Mule's language.
* A YAML file
+
Defines the configurable parameters of the policy. Rendered by the UI to display the input of the policy.
+
* The template's POM
+
Defines policy dependencies. Packaging type needs to be `mule-policy`. May define any Maven plugin that helps to manage
development lifecycle as any other Maven project.
* Resources
+
Optionally, if the policy depends on other resources, such as a certificate or a configuration properties file, it defines resources as part of the policy.
+
* The mule-artifact.json descriptor
+
Policies can not export resources nor packages.

== Basic XML structure
The basic structure of a policy config is as follows:

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:http-policy="http://www.mulesoft.org/schema/mule/http-policy">

  <http-policy:proxy name="policy-template">  // <1>
     <http-policy:source>  // <2>
          …  // <3>
         <http-policy:execute-next/> // <4>
          …  // <5>
      </http-policy:source>
  </http-policy:proxy>
</mule>
----

<1> The definition of a policy starts with the `http-policy:proxy` element and a name. The policy consists of two separated blocks where the behaviour is defined and are executed at different times. At least one of them has to be present. In this example, http-policy:source is used.
<2> `http-policy:source` is where the logic that is going to be executed around the whole flow is placed. This element allows you to inject a behavior before the flow processes the HTTP Request, and after the flow generates a response.
<3> Message Processors that are defined before the `execute-next` will be executed before the flow is reached.
<4> The `execute-next` element is required to continue the processing of the chain, which can trigger the execution of another policy or the application flow. Any policy can stop the execution chain by not executing execute-next.
<5> Message Processors that are defined after the `execute-next` will be executed after the flow is completed, thus the event will be the one which the flow generated.
Understanding execution order of policies

=== Understanding execution order

Consider the case where we have two policies, A and B.

Policy A has order 1 and Policy B has order 2.

Policy A is defined by the following config:

[source,xml,linenums]
----
  <http-policy:proxy name="policy-A">
     <http-policy:source>
          <A1 />
         <http-policy:execute-next/>
          <A2 />
      </http-policy:source>
  </http-policy:proxy>
----

Policy B config is:

[source,xml,linenums]
----
  <http-policy:proxy name="policy-B">
     <http-policy:source>
          <B1 />
         <http-policy:execute-next/>
          <B2 />
      </http-policy:source>
  </http-policy:proxy>
----

Finally, Flow is defined as:

[source,xml,linenums]
----
  <flow name="flow">
     <http:listener />
     <F1/>
  </flow>
----

When a Request arrives to the runtime, the execution order is as follows:

----
<A1> → <B1> → <F1> → <B2> → <A2>
----

As you can see, a policy with the lower order is the one that gets executed around the other ones, and flow is always the inner one.

By having this model, it is easy to avoid executing the next inner layer, by just avoiding the execution of the `execute-next` element.
For example, by placing it inside a `choice`, execution will be done or not depending a condition.

In this example, the flow is only going to be executed when the incoming request has a header called `myHeader` and its value is `someValue`.
If that is not the case, a message is logged.

[source,xml,linenums]
----
  <http-policy:proxy name="policy">
     <http-policy:source>
        <choice>
           <when expression=”#[attributes.headers[‘myHeader’] == ‘someValue’]” >
              <http-policy:execute-next/>
           </when>
           <otherwise>
              <logger message=”Avoid Flow execution” />
           </otherwise>
        </choice>
      </http-policy:source>
  </http-policy:proxy>
----

== Using extensions

Policies, just like applications, can make use of Mule extensions or plugins to extend Core capabilities. As in any Mule Application, when a policy needs to make use of Java Code, the recommended way to do it is through the use of SDK Extensions.

For this, the first step is to add a Maven dependency to that extension in policy's POM.

[source,xml,linenums]
----
   <dependencies>
       <dependency>
           <groupId>com.mulesoft.anypoint</groupId>
           <artifactId>mule-http-policy-transform-extension</artifactId>
           <version>1.0.0</version>
           <classifier>mule-plugin</classifier>
       </dependency>
   </dependencies>
----

Then, operations exposed by the dependency are available to be used within the policy's logic after adding the namespace

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns="http://www.mulesoft.org/schema/mule/core"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:http-policy="http://www.mulesoft.org/schema/mule/http-policy"
     xmlns:http-transform="http://www.mulesoft.org/schema/mule/http-policy-transform"
     xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
              http://www.mulesoft.org/schema/mule/http-policy http://www.mulesoft.org/schema/mule/http-policy/current/mule-http-policy.xsd
              http://www.mulesoft.org/schema/mule/http-policy-transform http://www.mulesoft.org/schema/mule/http-policy-transform/current/mule-http-policy-transform.xsd">

   <http-policy:proxy name="policy">
       <http-policy:source>
           <http-policy:execute-next/>

           <http-transform:add-headers outputType="response">
               <http-transform:headers>#[{'policyHeader': 'policyHeaderValue'}]</http-transform:headers>
           </http-transform:add-headers>
       </http-policy:source>
   </http-policy:proxy>
</mule>
----

NOTE: It is not possible to use a Java Module from policies. The Java Module requires that a policy exports the Java classes it has to use. and policies are not allowed to export packages nor resources.

== Outbound policies

One of the main additions is that now policies can also be applied on outbound HTTP Requests and not only on the inbound HTTP Requests. This means that in proxy scenarios, where the flow has an HTTP Requester defined, things like adding headers to only that request or doing some sort of traffic shaping on the outbound are now possible.

*Basic structure of a policy that defines both source and operation blocks is as follows:*

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:http-policy="http://www.mulesoft.org/schema/mule/http-policy">

  <http-policy:proxy name="policy-template">  // <1>
      <http-policy:operation> // <2>
     …
      <http-policy:execute-next/>
     …
      </http-policy:operation>
  </http-policy:proxy>
</mule>
----

<1> Same `http-policy:proxy` element is used for both types of policies. Both source and operation blocks may be present. At least one of them is mandatory. When both are present things like sharing variables between them are possible to keep state.
<2> Operation is where the logic that is going to be executed around the flow’s HTTP Requester is placed. If flow does not contain that element, then this block is never executed. This element allows you to inject a behavior before an HTTP Request is sent to a proxy’s backend and after an HTTP Response is received by the proxy. Just like source block, the execute-next element divides when processors are executed.

*Execution order example*

Consider the case where we have two policies, A and B.

Policy A has order 1 and Policy B has order 2.

Policy A is defined by the following config:

[source,xml,linenums]
----
  <http-policy:proxy name="policy-A">
     <http-policy:source>
        <A1 />
        <http-policy:execute-next/>
        <A2 />
     </http-policy:source>

     <http-policy:operation>
        <A3 />
        <http-policy:execute-next/>
        <A4 />
     </http-policy:operation>
  </http-policy:proxy>
----

Policy B config is:

[source,xml,linenums]
----
  <http-policy:proxy name="policy-B">
     <http-policy:source>
        <B1 />
        <http-policy:execute-next/>
        <B2 />
     </http-policy:source>

     <http-policy:operation>
        <B3 />
        <http-policy:execute-next/>
        <B4 />
     </http-policy:operation>
  </http-policy:proxy>
----

Finally, Flow is defined as:

[source,xml,linenums]
----
  <flow name="flow">
      <http:listener />
      <F1/>
      <http:requester />
      <F2/>
  </flow>
----

When a Request arrives to the runtime, the execution order is as follows:

----
<A1> → <B1> → <F1> → <A3> → <B3> → <http:requester> → <B4> → <A4> → <F2> → <B2> → <A2>
----

As you can see, operation policies are injected only around the `http:requester`.

== Error Handling

Another new feature, that can be achieved using policies, is handling errors thrown by the policy and even errors thrown by the flow or other policies within it. This is done using Mule’s `try` and `error-handler` elements.

Once an error is caught by an `error-handler`, it is either propagated, in which case the error jumps into the outer chain, or it is completely handled, in which case the outer chain execution continues normally.

To put an example, consider the following policy and flow:

[source,xml,linenums]
----
  <http-policy:proxy name="policy">
     <http-policy:source>
        <try>
           <P1 />
           <http-policy:execute-next/>
           <P2 />
           <error-handler>
              <on-error-continue>
                 <PEH />
              </on-error-continue>
           </error-handler>
        </try>
      </http-policy:source>
  </http-policy:proxy>
----

[source,xml,linenums]
----
  <flow name="flow">
     <http:listener />
     <F1 />
     <F2 />
     <error-handler>
        <on-error-continue>
           <FEH />
        </on-error-continue>
     </error-handler>
  </flow>
----

We can explore a couple of scenarios where an error is thrown from different processors.

Consider that `<F1>`, defined in the flow, is the one that raises an error, then the execution order is as follows:

----
<P1> → <F1> → <FEH> → <P2>
----

`<F2>`, is not executed at all, and processing continues into the flow’s error-handler after error is raised.
Also, as flow’s error-handler is configured to not propagate errors, when execution returns to the policy, error is already handled and processing continues normally, by executing `<P2>` instead of the policy’s `error-handler`.

Now consider that `<P1>`, defined in the policy, is the one that raises the error. In that case execution order is

----
<P1> → <PEH>
----

The flow is never reached, so this is another way that a flow can be conditionally executed.

We can go through similar scenarios, but consider that `error-handler` is configured to *propagate* errors. In that case, error handler is defined as:

[source,xml,linenums]
----
  <error-handler>
     <on-error-propagate>
        <FEH />
     </on-error-propagate>
  </error-handler>
----

Considering the first scenario where `<F1>` element raises an error, the execution order would be:

----
<P1> → <F1> → <FEH> → <PEH>
----

Notice that in this case, after the flow’s `error-handler` finishes to execute, the error is passed to the policy as well, and the policy execution continues into the policy’s `error-handler`


== Classloading isolation

Just like applications, classloading isolation affects policies. This means that any resource or library that one policy
defines, is not visible by other policies.

Classloading isolation is a complex matter, but policies only care about what they use and do not care about exporting things for others to use, like Mule extensions or plugins.

Something important to notice, is that between policies and applications there is not complete isolation. It is a similar scenario of applications and domains. Whatever plugin, library or resource is visible by the application, is also visible by any policy applied to that application. The other way around is not true.

In the case a policy and the application are both using different versions of the same dependency, then the application one prevails.

One limitation is that policies can not export resources or Java classes for others to use. Validations on this are present in Mule Packager from versions 3.2.0+.

More on classloading isolation: https://docs.mulesoft.com/mule4-user-guide/v/4.1/about-classloading-isolation

== Variables and Message Scope

A policy can define any number of variables and can make any changes to Mule's message it wants.

=== Variables

Nevertheless, variables have local scope. This means that variables defined in a policy are not available in other policies nor
in the application. Also, variables defined by the application are not available to any other policy. If a policy with both source
and operation blocks is defined, then variables are shared between blocks.

=== Source policies

Also, not every modification that is made to a Message is propagated to other policies or to the application.
We need to distinguish between source and operation policies to explain Message propagation.

Let's start with source policies. When a modification to a Mule Message is made *after* the `execute-next` element, the element is propagated as is. As an example of this, consider the following policy and flow:

[source,xml,linenums]
----
<http-policy:proxy name="policy">
  <http-policy:source>
     <http-policy:execute-next/>
     <set-payload value="Policy Message" />
   </http-policy:source>
</http-policy:proxy>
----

[source,xml,linenums]
----
<flow name="flow">
  <http:listener />
  <set-payload value="Flow Message" />
</flow>
----

When an incoming request arrives to the runtime, the HTTP Response will contain "Policy Message" as the body.

But, modifications made *before* the `execute-next` element are not propagated by default to next policy or to application. Let's
view this:

[source,xml,linenums]
----
<http-policy:proxy name="policy">
  <http-policy:source>
     <set-payload value="Policy Message" />
     <http-policy:execute-next/>
  </http-policy:source>
</http-policy:proxy>
----

[source,xml,linenums]
----
<flow name="flow">
  <http:listener />
  <logger message=#[payload] />
</flow>
----

When an incoming request arrives to the runtime, the HTTP Response will contain an empty body. Also, the LOGGER placed in the flow will display an empty message.

However, there is a way to change this behaviour and this is through a policy attribute called `propagateMessageTransformations`.
When that property is enabled, then modifications made before `execute-next` are in fact propagated to next policy or application.

[source,xml,linenums]
----
<http-policy:proxy name="policy">
  <http-policy:source propagateMessageTransformations="true">
     <set-payload value="Policy Message" />
     <http-policy:execute-next/>
  </http-policy:source>
</http-policy:proxy>
----

[source,xml,linenums]
----
<flow name="flow">
  <http:listener />
  <logger message=#[payload] />
</flow>
----

In this scenario, when an incoming request arrives to the runtime, the HTTP Response will contain "Policy Message" as a body. Also,
the LOGGER placed in the flow, will display "Policy Message" as a message.

This decision was made so a policy developer explicitly defines that a policy is changing what the application would have received,
if the policy was not there. This way, unintentional modifications won't affect flow execution.

=== Operation policies

Now, about operation policies, the case is similar to what have just been explained with a twist. In operation policies, modifications
made before the `execute-next` element are always propagated. Modifications made after it, are not propagated by default, but can
be enabled using the same flag on the operation policy definition.

[source,xml,linenums]
----
<http-policy:proxy name="scope-payload">
   <http-policy:operation propagateMessageTransformations="true">
       …
       <http-policy:execute-next/>
       …
   </http-policy:operation>
</http-policy:proxy>
----

The logic here is also similar. If the policy developer wants to modify what would have been received by the application, then it
has to be explicit about it.

=== Authentication (Security Context)

So, in summary, variables can not be used to expose information from a policy, but a Message can. Another way to expose information
related to user Authentication is the Authentication object of the Security context.

If a policy sets this object, it will also be available to other policies and to the application. The way of accessing this
information is using a DataWeave expression:

----
#[authentication.principal]
#[authentication.password]
#[authentication.properties.someProperty]
----

Right now, the only way to set this object is through the use of a SDK Mule extension. How to do it, can be found here:
xref:mule-sdk::authentication-handler.adoc

This is how we are going to propagate Client information in our out-of-the-box policies, for example.

== YAML Configuration File
Mule’s policies are composed by an XML configuration where the business logic is defined and also by a YAML file where metadata
and user parameters of that logic is defined.

It is a really common case that the same policy has to be applied to multiple APIs. It is also really common that in some other
cases a different configuration of a policy is desired depending on the API.

A great example of this is the Rate Limit Policy. A user may want to allow up to 100 requests per minute on a certain API, and that could be 5000 requests per minute on a different API.

To allow these types of different configurations, policy developers may define that a policy has certain parameters that the user has to set when applying it.

Those parameters are defined in the YAML Configuration File. This configuration is then used by API Manager to render the UI that is displayed when trying to apply the policy. Policies parameters will be shown as user inputs at that moment.

*Example of Client ID enforcement YAML file*

[source,yaml,linenums]
----
id: openam-access-token-enforcement  // <1>
name: OpenAM access token enforcement  // <2>
supportedPoliciesVersions: '>=v4'  // <3>
description: Enforces access tokens by OpenAM.  // <4>
category: Security  // <5>
violationCategory: authentication  // <6>
type: system  // <7>
resourceLevelSupported: true  // <8>
standalone: true  // <9>
requiredCharacteristics: []  // <10>
identityManagement:  // <11>
type: OpenAM
providedCharacteristics:  // <12>
- OAuth 2.0 protected
configuration:  // <13>
- propertyName: scopes
  name: Scopes
  description: A space-separated list of supported scopes
  type: string
  optional: true
  sensitive: false
  allowMultiple: false
- propertyName: exposeHeaders
  name: Expose Headers
  description: In a proxy scenario, defines if headers should be exposed in the request to the backend. The headers that may
      be sent are the user properties returned by the federation server when validating the access token with a 'X-AGW-' prefix.
  type: boolean
  optional: true
  defaultValue: true
  allowMultiple: false
----

<1> Unique ID within your organization of the policy. Mandatory
<2> User friendly name that is used for displaying the policy name in API Manager’s UI. Mandatory
<3> Deprecated property. Value should be set to ‘>=v1’ for now. Mandatory
<4> Description of what the policy does. Also used in API Manager’s UI. Mandatory
<5> Category to which the policy belongs. Used to group and filter policies in API Manager’s UI, any String value is valid. Mandatory
<6> Deprecated property. Value should be set to ‘system’. Mandatory
<7> Value used by the Edge to show metrics about different types of policy violations. Mandatory
<8> Whether resource level pointcuts should be enabled when applying the policy. Mandatory
<9> Deprecated property. Value should be set to ‘true’. Mandatory
<10> Deprecated property. Value should be set to ‘[]’. Mandatory
<11> Whether policy requires information about an identity management that is configured to the API’s Organization. Optional
<12> Which characteristic does the policy provides. Is used as another filter in API Manager’s UI. It expects an array of values. Mandatory
<13> Where the policy parameters are defined. Every parameter listed here will be rendered as an expected user input in API Manager’s UI. It expects an array of values. Mandatory

Let’s take a look on the syntax for defining policy’s parameters.

[source,yaml,linenums]
----
  propertyName: scopes // <1>
  name: Scopes // <2>
  description: A space-separated list of supported scopes // <3>
  type: string // <4>
  defaultValue: some String // <5>
  optional: true // <6>
  sensitive: false // <7>
  allowMultiple: false // <8>
----

<1> Internal name of the parameter. Must be unique within the policy.
<2> User friendly name of the parameter. Used for displaying in API Manager’s UI.
<3> Description of the parameter. Also, used for displaying in API Manager’s UI.
<4> Type of the parameter.
<5> Default value for the parameter.
<6> Whether is mandatory for the user to enter this value or not.
<7> Whether this property should be masked when entering in API Manager’s UI.
<8> Whether multiple values should be allowed for this parameter.

=== Parameter types
Depending of the type of the parameter, the UI will render a different type of input, like text boxes, radio buttons, checkboxes, etc.
Also, as some of this rendered elements require additional configuration, depending on the type, some additional properties may be required.

The list of available types consists of:

* *String*: Any string expected
* *Expression*: A DataWeave expression starting with #[ and finished with ] is expected
* *Boolean*: true or false
* *Int*: A number is expected. This type requires additional properties

[source,yaml,linenums]
----
  minimumValue: -1 // <1>
  maximumValue: 2147483647 // <2>
----

<1> Minimum value allowed for the parameter
<2> Maximum value allowed for the parameter

* *Radio*: One value of a group of options. This type requires additional properties

[source,yaml,linenums]
----
Options: // <1>
- name: HTTP Basic Authentication Header
  value: httpBasicAuthenticationHeader
- name: Custom Expression
  value: customExpression
----

<1> Array of options among which the user has to select one. Each option has a name used for displaying in the UI and an internal value that is going to be used in the policy

* *Keyvalues*: Collection of Key-Value pairs.

== HandleBars
Policies support Handlebars, a templating engine for resolving the configurable parameters of the policy and implementing semantic logic, such as conditionals.
This is the way to use the user inputs in the policies.

Each policy parameter defined in YAML Configuration file will be available as a HandleBars variable for resolving the definitive policy configuration.

Note: Handlebars is an extension of Mustache, which was used in earlier versions.

Depending on the parameter type defined in the YAML, the variable will be of a different HandleBars type.

String, Expression, Radio, Int and Boolean end up being primitives types in HandleBars.

This types can be referenced from the policy template using curly brackets:
`{{{myproperty}}}`

Keyvalues are complex types in HandleBars. Complex types have inner properties and those can be referenced as follows:

----
{{{keyvalue.key}}}
{{{keyvalue.value}}}
----

There are some properties that are available to use in policies without being defined in YAML Configuration file:

* *policyId* id of the policy, useful for logging or naming a policy
* *isWsdlEndpoint* indicates whether the API where the policy is being applied is a WSDL API

When an Identity Management is defined for the organization where the API where the policy is being applied, then the following
properties are also available

*identityManagementTokenUrl* introspection endpoint of the identity management
*identityManagementClientId* client Id for authenticating to the introspection endpoint
*identityManagementClientSecret* client secret for authenticating to the introspection endpoint

== Pointcuts
In earlier versions, the pointcut element was required to configure a custom policy. It specified to which API the policy was going to be applied.
In Mule 4, you don’t need to configure the pointcut. This information is provided by API Manager when a policy is applied. See offline policies for configuration guidelines, when a policy is not applied online.

== Advanced topics
**** xref:http-policy-transform.adoc[Reviewing HTTP Policy Transform Extension]
**** xref:add-remove-headers-latest-task.adoc[Adding/Removing Headers Custom Policy]
**** xref:add-remove-headers-concept.adoc[Adding/Removing headers Custom Policy example]
**** xref:add-remove-headers.adoc[Testing removing headers Custom Policy example]
**** xref:caching-in-a-custom-policy-mule-4.adoc[Removing HTTP Caching Custom Policy example]

== See also
**** xref:custom-policy-packaging-policy.adoc[Packaging a Custom Policy]
**** xref:custom-policy-uploading-to-exchange.adoc[Uploading a Custom Policy to Exchange]
